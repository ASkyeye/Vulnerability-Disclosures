// McShieldRpcClient.cpp : Defines the functions for the static library.
//

#include "McShieldRpcClient.h"
#include "AvSolution_h.h"
#include "wil/resource.h"
#include "wil/rpc_helpers.h"
#include <string>
#include <stdexcept>
#include <iostream>

using unique_avsolution_context = wil::unique_rpc_context_handle<void *, decltype(&Proc1_Close), Proc1_Close>;

handle_t s_interfaceBinding;

McShieldRpcClient::McShieldRpcClient()
{
    wchar_t protocolSequence[] = L"ncalrpc";
    wchar_t endpoint[] = L"avsolution_endpoint";
    wchar_t *stringBinding;

    auto rpcStatus = ::RpcStringBindingCompose(
        nullptr,
        reinterpret_cast<RPC_WSTR>(protocolSequence),
        nullptr,
        reinterpret_cast<RPC_WSTR>(endpoint),
        nullptr,
        reinterpret_cast<RPC_WSTR *>(&stringBinding));
    if (rpcStatus != RPC_S_OK)
        throw std::runtime_error("RpcStringBindingCompose failed. Error: " + std::to_string(rpcStatus));

    auto freeStringBinding = wil::scope_exit(
        [stringBinding]() mutable { ::RpcStringFree(reinterpret_cast<RPC_WSTR *>(&stringBinding)); });

    rpcStatus = ::RpcBindingFromStringBinding(
        reinterpret_cast<RPC_WSTR>(stringBinding), &s_interfaceBinding);
    if (rpcStatus != RPC_S_OK)
        throw std::runtime_error("RpcBindingFromStringBinding failed. Error: " + std::to_string(rpcStatus));
}

McShieldRpcClient::~McShieldRpcClient()
{
    try
    {
        auto rpcStatus = ::RpcBindingFree(&s_interfaceBinding);
        if (rpcStatus != RPC_S_OK)
            throw std::runtime_error("RpcBindingFree failed. Error: " + std::to_string(rpcStatus));
    }
    catch (...)
    {
        // ToDo: Log error
    }
}

void McShieldRpcClient::Scan(const wchar_t *filePath)
{
    unique_avsolution_context clientContext;
    long processId;

    wil::invoke_rpc(&Proc0_Open, clientContext.put(), 0x10000, &processId, 0x12345678);

    long pipeToken;
    int64_t pipeHandle;

    wil::invoke_rpc(&Proc2_GetPipeToken, clientContext.get(), &pipeToken, &pipeHandle);

    wchar_t policyKey[] = L"LAMODSTRUSTSCAN";
    int64_t scanner;

    wil::invoke_rpc(&Proc19_PPCreateScanner, clientContext.get(), policyKey, &scanner);
    auto destroyScannerOnExit = wil::scope_exit(
        [&clientContext, &scanner]() { wil::invoke_rpc_nothrow(&Proc21_PPDestroyScanner, clientContext.get(), &scanner); });

    wil::invoke_rpc(&Proc20_ScannerSetToken, clientContext.get(), scanner, /*pipeToken*/ 0);

    union_150 union150;
    union150.unionMember_1.StructMember0 = const_cast<wchar_t *>(filePath);
    union150.unionMember_1.StructMember1 = nullptr;
    union150.unionMember_1.StructMember2 = nullptr;

    long finalResult;

    Struct_264_t struct264 = {};
    Struct_290_t struct290 = {};

    wil::invoke_rpc(&Proc22_PPScan, clientContext.get(), scanner, static_cast<short>(1), &union150, &finalResult, 5, 6, 7, 8, &struct264, &struct290, nullptr, 12, 0x3e7, 14, 15, processId, 0);
}

/******************************************************/
/*         MIDL allocate and free                     */
/******************************************************/

void __RPC_FAR *__RPC_USER midl_user_allocate(size_t len)
{
    return ::malloc(len);
}

void __RPC_USER midl_user_free(void __RPC_FAR *ptr)
{
    ::free(ptr);
}
