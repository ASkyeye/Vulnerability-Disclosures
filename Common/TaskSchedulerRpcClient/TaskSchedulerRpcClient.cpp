#include "TaskSchedulerRpcClient.h"
#include "SchRpc_h.h"
#include "wil/resource.h"
#include "wil/rpc_helpers.h"
#include <string>
#include <stdexcept>

constexpr auto g_systemTaskXmlTemplate =
    L"<?xml version=\"1.0\" encoding=\"UTF-16\"?>"
    L"<Task version=\"1.3\" xmlns=\"http://schemas.microsoft.com/windows/2004/02/mit/task\">"
    L"  <RegistrationInfo />"
    L"  <Triggers>"
    L"    <TimeTrigger>"
    L"      <StartBoundary>2023-02-05T22:55:00Z</StartBoundary>"
    L"      <Enabled>true</Enabled>"
    L"    </TimeTrigger>"
    L"  </Triggers>"
    L"  <Principals>"
    L"    <Principal>"
    L"      <UserId>S-1-5-18</UserId>"
    L"      <RunLevel>HighestAvailable</RunLevel>"
    L"    </Principal>"
    L"  </Principals>"
    L"  <Settings>"
    L"    <MultipleInstancesPolicy>IgnoreNew</MultipleInstancesPolicy>"
    L"    <DisallowStartIfOnBatteries>true</DisallowStartIfOnBatteries>"
    L"    <StopIfGoingOnBatteries>true</StopIfGoingOnBatteries>"
    L"    <AllowHardTerminate>true</AllowHardTerminate>"
    L"    <StartWhenAvailable>false</StartWhenAvailable>"
    L"    <RunOnlyIfNetworkAvailable>false</RunOnlyIfNetworkAvailable>"
    L"    <IdleSettings>"
    L"    <Duration>PT10M</Duration>"
    L"    <WaitTimeout>PT1H</WaitTimeout>"
    L"    <StopOnIdleEnd>true</StopOnIdleEnd>"
    L"    <RestartOnIdle>false</RestartOnIdle>"
    L"    </IdleSettings>"
    L"    <AllowStartOnDemand>true</AllowStartOnDemand>"
    L"    <Enabled>true</Enabled>"
    L"    <Hidden>false</Hidden>"
    L"    <RunOnlyIfIdle>false</RunOnlyIfIdle>"
    L"    <DisallowStartOnRemoteAppSession>false</DisallowStartOnRemoteAppSession>"
    L"    <UseUnifiedSchedulingEngine>true</UseUnifiedSchedulingEngine>"
    L"    <WakeToRun>false</WakeToRun>"
    L"    <ExecutionTimeLimit>PT72H</ExecutionTimeLimit>"
    L"    <Priority>7</Priority>"
    L"  </Settings>"
    L"  <Actions>"
    L"    <Exec>"
    L"      <Command>%ws</Command>"
    L"      <Arguments>%ws</Arguments>"
    L"    </Exec>"
    L"  </Actions>"
    L"</Task>";

constexpr auto g_everyoneFullAccessSDDL = L"D:(A;OICI;FA;;;WD)";

TaskSchedulerRpcClient::TaskSchedulerRpcClient()
{
    wchar_t interfaceUuid[] = L"86D35949-83C9-4044-B424-DB363231FD0C";
    wchar_t protocolSequence[] = L"ncalrpc";
    wchar_t *stringBinding;

    auto rpcStatus = ::RpcStringBindingCompose(
        reinterpret_cast<RPC_WSTR>(interfaceUuid),
        reinterpret_cast<RPC_WSTR>(protocolSequence),
        nullptr,
        nullptr,
        nullptr,
        reinterpret_cast<RPC_WSTR *>(&stringBinding));
    if (rpcStatus != RPC_S_OK)
        throw std::runtime_error("RpcStringBindingCompose failed. Error: " + std::to_string(rpcStatus));

    auto freeStringBinding = wil::scope_exit(
        [stringBinding] () mutable { ::RpcStringFree(reinterpret_cast<RPC_WSTR *>(&stringBinding)); });

    rpcStatus = ::RpcBindingFromStringBinding(
        reinterpret_cast<RPC_WSTR>(stringBinding), &m_interfaceBinding);
    if (rpcStatus != RPC_S_OK)
        throw std::runtime_error("RpcBindingFromStringBinding failed. Error: " + std::to_string(rpcStatus));
}

TaskSchedulerRpcClient::~TaskSchedulerRpcClient()
{
    try
    {
        auto rpcStatus = ::RpcBindingFree(&m_interfaceBinding);
        if (rpcStatus != RPC_S_OK)
            throw std::runtime_error("RpcBindingFree failed. Error: " + std::to_string(rpcStatus));
    }
    catch (...)
    {
        // ToDo: Log error
    }
}

void TaskSchedulerRpcClient::RegisterTaskAsSystem(
    const wchar_t *path, const wchar_t *command, const wchar_t *arguments)
{
    wchar_t systemTaskXml[4096];
    swprintf_s(systemTaskXml, g_systemTaskXmlTemplate, command, arguments);

    wchar_t *pActualPath = nullptr;
    TASK_XML_ERROR_INFO *pErrorInfo = nullptr;

    wil::invoke_rpc(SchRpcRegisterTask, 
        m_interfaceBinding,
        path,
        systemTaskXml,
        2 /*TASK_CREATE*/,
        g_everyoneFullAccessSDDL,
        0 /*TASK_LOGON_NONE */,
        0, nullptr,
        &pActualPath, &pErrorInfo);
}

/******************************************************/
/*         MIDL allocate and free                     */
/******************************************************/

void __RPC_FAR *__RPC_USER midl_user_allocate(size_t len)
{
    return (::malloc(len));
}

void __RPC_USER midl_user_free(void __RPC_FAR *ptr)
{
    ::free(ptr);
}
