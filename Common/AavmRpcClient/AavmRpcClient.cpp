// AavmRpcClient.cpp : Defines the functions for the static library.
//


#include "AavmRpcClient.h"
#include "Aavm_h.h"
#include "wil/resource.h"
#include "wil/rpc_helpers.h"
#include <string>
#include <stdexcept>

using unique_aavm_context = wil::unique_rpc_context_handle<void *, decltype(&Proc1_AavmFreeHandle), Proc1_AavmFreeHandle>;

AavmRpcClient::AavmRpcClient()
{
    wchar_t protocolSequence[] = L"ncalrpc";
    wchar_t endpoint[] = L"[Aavm]";
    wchar_t *stringBinding;

    auto rpcStatus = ::RpcStringBindingCompose(
        nullptr,
        reinterpret_cast<RPC_WSTR>(protocolSequence),
        nullptr,
        reinterpret_cast<RPC_WSTR>(endpoint),
        nullptr,
        reinterpret_cast<RPC_WSTR *>(&stringBinding));
    if (rpcStatus != RPC_S_OK)
        throw std::runtime_error("RpcStringBindingCompose failed. Error: " + std::to_string(rpcStatus));

    auto freeStringBinding = wil::scope_exit(
        [stringBinding]() mutable { ::RpcStringFree(reinterpret_cast<RPC_WSTR *>(&stringBinding)); });

    rpcStatus = ::RpcBindingFromStringBinding(
        reinterpret_cast<RPC_WSTR>(stringBinding), &m_interfaceBinding);
    if (rpcStatus != RPC_S_OK)
        throw std::runtime_error("RpcBindingFromStringBinding failed. Error: " + std::to_string(rpcStatus));
}

AavmRpcClient::~AavmRpcClient()
{
    try
    {
        auto rpcStatus = ::RpcBindingFree(&m_interfaceBinding);
        if (rpcStatus != RPC_S_OK)
            throw std::runtime_error("RpcBindingFree failed. Error: " + std::to_string(rpcStatus));
    }
    catch (...)
    {
        // ToDo: Log error
    }
}

void AavmRpcClient::ArbitraryFileMove(const wchar_t *srcFilePath, const wchar_t *dstFilePath)
{
    unique_aavm_context aavmContext;
    THROW_IF_FAILED(wil::invoke_rpc_result_nothrow(
        static_cast<void *&>(*aavmContext.put()), &Proc0_AavmGetHandle, m_interfaceBinding));

    std::wstring sourceFilePath = srcFilePath;
    std::wstring destinationFilePath = dstFilePath;

    DWORD lastError;
    THROW_IF_FAILED(wil::invoke_rpc_result_nothrow(
        lastError, &Proc81, aavmContext.get(), &sourceFilePath[0], &destinationFilePath[0], 1 /* MOVEFILE_REPLACE_EXISTING */));
    THROW_IF_WIN32_ERROR(lastError);
}

void AavmRpcClient::ArbitraryFileResetSecurity(const wchar_t *filePath)
{
    unique_aavm_context aavmContext;
    THROW_IF_FAILED(wil::invoke_rpc_result_nothrow(
        static_cast<void *&>(*aavmContext.put()), &Proc0_AavmGetHandle, m_interfaceBinding));

    std::wstring targetFilePath = filePath;

    DWORD lastError;
    THROW_IF_FAILED(wil::invoke_rpc_result_nothrow(
        lastError, &Proc64, aavmContext.get(), &targetFilePath[0], 0, 0));
    THROW_IF_WIN32_ERROR(lastError);
}

void AavmRpcClient::CreateElevatedProcess(const wchar_t *commandLine, HANDLE *hThread)
{
    unique_aavm_context aavmContext;
    THROW_IF_FAILED(wil::invoke_rpc_result_nothrow(
        static_cast<void *&>(*aavmContext.put()), &Proc0_AavmGetHandle, m_interfaceBinding));

    std::wstring processCommandLine = commandLine;
    std::wstring unknown = L"unknown";

    DWORD lastError;
    THROW_IF_FAILED(wil::invoke_rpc_result_nothrow(
        lastError, &Proc60, aavmContext.get(), 2, &processCommandLine[0], ::GetCurrentProcessId(), &unknown[0], reinterpret_cast<long *>(hThread)));
    THROW_IF_WIN32_ERROR(lastError);
}

void AavmRpcClient::ArbitraryFileDelete(const wchar_t *filePath)
{
    unique_aavm_context aavmContext;
    THROW_IF_FAILED(wil::invoke_rpc_result_nothrow(
        static_cast<void *&>(*aavmContext.put()), &Proc0_AavmGetHandle, m_interfaceBinding));

    std::wstring targetFilePath = filePath;

    DWORD lastError;
    THROW_IF_FAILED(wil::invoke_rpc_result_nothrow(lastError, &Proc80, aavmContext.get(), &targetFilePath[0]));
    THROW_IF_WIN32_ERROR(lastError);
}

/******************************************************/
/*         MIDL allocate and free                     */
/******************************************************/

void __RPC_FAR *__RPC_USER midl_user_allocate(size_t len)
{
    return (::malloc(len));
}

void __RPC_USER midl_user_free(void __RPC_FAR *ptr)
{
    ::free(ptr);
}
